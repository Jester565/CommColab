Do we have to support C++98 or can we go all C++11?

We need some way of specifying if a methods been overriden, like the override keyword in C++11.

Whats the purpose of the typedef at the bottom of abstractpacket.h?

Whats the purpose of GetValue(AbstractPacket&) in abstractpacket... Can't we just cast it normally?

Is the packets.h file just an example?

Why is the CommThread constructor create a thread then using that thread to initialize the attribute thr in the constructor (do you want to call the move constructor or something)?

What is the purpose of obtain_api_version in api.h?

Why are the Header Files in the architecture folder in visual studio?

Why is structure always put in front of address_in?

PacketTable is an unfinished version of std::unordered_list... Why not just use std::unordered_list?  Also why make a Pair class when std::pair exists?

After defining __COMMS_DEBUG_FATAL_EXIT, a call to comms_fatal. The program will not exit, maybe change the name if thats not the behavior we want.

Whats the point of call in comms_fatal? (Changed it so it works now. I think.)

Inserting a Packet into the PacketTable should be guaranteed.  After that, returning a boolean on all of the calls won't be necessary.

HUGE LOGIC ERROR!!!  GetCallback is not accounting that insert will just iterate along the hashtable until it finds an open position.  Needs fixing!

What is the purpose of PacketFactory id?

There is a DEFAULT_TABLE_SIZE in packetmanager and a DEFAULT_TABLE_SIZE in PacketTable, we need to decide which one we are going to use.

Is Contains(Callback* call) in PacketManager necessary?

We should get rid of size and MaxSize in PacketManager, this is already in PacketTable.

What's up with the naming convention between size and MaxSize in PacketManager.  One is capatilized and one isn't.

When will CommNode's unique_id ever be used?

MEMORY LEAK???  CommNode destructor not deleting elements inside the queue.  Just deletes the queue.  //Don't take this seriously yet, I still need to look at the implementation.