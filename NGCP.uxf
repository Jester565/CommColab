<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.2">
  <zoom_level>8</zoom_level>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>144</x>
      <y>536</y>
      <w>256</w>
      <h>368</h>
    </coordinates>
    <panel_attributes>//Abstract class to be used for determining what data should be sent and what callback to use when received.  Has a unique key to distinguish it from other packets.
AbstractPacket
--
public:
//New instance of AbstractPacket, sets the typeID attribute to the hash of typeIDHashKey
AbstractPacket(const char* typeIDHashKey);

//Accessor for the id of the packet, used to set the msg_id of a header
uint32_t GetID() const;

//Serializes the contents of the packet to the outStream parameter (pure virtual).  Called by Comm::send.
void Pack(ObjectStream&amp; outStream) = 0;

//Parses the contents of the packet from the inStream parameter (pure virtual)
void Unpack(ObjectStream&amp; inStream) = 0;

//Casts AbstractPacket to Type and returns it (return by reference evil?)
static Type&amp; GetValue(AbstractPacket&amp; packet);

//Returns a new instance of some child of AbstractPacket (pure virtual).  Used by PacketFactory.
AbstractPacket* Create() = 0;

//Default destructor
~AbstractPacket();

private:
//Default constructor (maybe this shouldn't exist?)
AbstractPacket();

//Accessed by getID(), set by constructor. Identification number for the packet.
uint32_t type_id;

--

//Call from child's constructor to AbstractPacket's constructor.  Pass in the type of the child and it
//will be converted into a const char* and be passed into AbstractPacket constructor as classname parameter.
CHAIN_ABSPACKET(class_name)

//Example - class Packet : INHERITS_ABSPACKET {};
INHERITS_ABSPACKET

//Defined as the name of the class representing the abstractpacket (so in this case comnet::AbstractPacket)
ABSPACKET</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>0</x>
      <y>1896</y>
      <w>248</w>
      <h>408</h>
    </coordinates>
    <panel_attributes>api.h
--

--
//Hexidecmial representatoin of the minimum version of the library
_COMNET_MINIMUM_API_VERSION_

//Hexidecimal representation of the last version of the library that has the same method names (no deprecated methods)
_COMNET_COMPATIBLE_API_VERSOIN_

//Hexidecimal representation of the current version of the library (Should be greater than COMENT_COMPATIBLE_API_VERSION_ and COMNET_MINIMUM_API_VERSION_
_COMNET_CURRENT_API_VERSION_

//I still don't really know what this does... you pass it one of the API_VERSOIN defines and it just gives you the hexideceimal (so it just returns the parameter you passed it...)
obtain_api_version(_api_version)

//Put before classes to denote what part of the API they are (public in this case).  Never get rid of this define or the program won't compile.
_COMNET_PUBLIC_API_

//Put before classes to denote what part of the API they are (general in this case).  Never get rid of this define or the program won't compile.
_COMNET_API_

//Put before classes to denote what part of the API they are (private in this case).  Never get rid of this define or the program won't compile.
_COMNET_API_PRIVATE_

//Not implemented anywhere yet.  Denotes how much implementers of the library will have to see the classes 0 means they will probably never see it and 5 means they will see it.  Just a guess though.
_COMNET_API_LEVEL_(UNKNOWN, 0, 1, 2,3,4,5)_

//Replace for class so that the class behaving as an interface is more clear.  Not implemented anywhere.
_COMNET_INTERFACE_

//Replace for class so that the class behaving as an abstract class is more clear.  Not implemented anywhere.
_COMNET_ABSTRACT_

//Replace for class so that the class behaving as a normal class is more clear.  Not implemented anywhere.
_CLASS_

//Retunrs the value of _COMNET_CURRENT_API_VERSION_
_current_api_version obtain_api_version(_COMNET_CURRENT_API_VERSION_)

//This define is put in classes that should be apart of the DLL.  However, when in static library mode, this is left blank.
COMM_EXPORT

//Not sure what the purpose of this is.  Usually the linker will figure out dll imports for you.
COMM_IMPORT

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>48</x>
      <y>1624</y>
      <w>152</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>arch.h
--

--
//Set to one of the defines below based on macro detection of which OS the library is being built on
COM_TARGET_OS

COM_OS_UNKNOWN

COM_OS_WINDOWS

COM_OS_LINUX

//Not used
COM_OS_QX

//Not used
COM_OS_BSD</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>112</x>
      <y>1816</y>
      <w>24</w>
      <h>96</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>424</x>
      <y>2512</y>
      <w>320</w>
      <h>304</h>
    </coordinates>
    <panel_attributes>Comms
--
private:
-CommMutex send_mutex;
-CommMutex recv_mutex;
-CommMutex console_mutex;
-CommConditionVariable comm_cond_var_send;
-uint32_t rx_length;
-CommThread comm_thread_send;
-CommThread comm_thread_recv;
-CommThread console_thread;
-void CommunicationHandlerSend();
-void CommunicationHandlerRecv();
-CommsLink *conn_layer;
-encryption::CommEncryptor encrypt;
-encryption::CommDecryptor decrypt;
-std::shared_ptr &lt;ConnectionStateManager&gt; conStateManager;

public:		
+Comms(uint8_t platform_id);
+~Comms();
+bool LoadKey(char* key);
+bool LoadKeyFromFile(char*keyFileName);</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>440</x>
      <y>2128</y>
      <w>272</w>
      <h>336</h>
    </coordinates>
    <panel_attributes>//Abstract class that will allow for easy adjustments in node changing and style.
/CommsNode/
--
//Initially 0, is incremented every time a CommNode is created so the value of unique_id can be set to this value.
static uint16_t number_of_nodes;

//Sets unique_id to number_of_nodes, increments number_of_nodes.  Sets attributes to default.
CommNode();

//Sets node_id to the parameter platform_id (this name is a bit confusing to me).
//Sets unique_id to number_of_nodes, increments number_of_nodes.  Sets attributes to default.
CommNode(const uint32_t platform_id);

//Delets the recv_queue and send_queue
//MEMEORY LEAK: Elements inside the queues are not deleted! (Not too sure about this yet)
~CommNode();

//Calls packet_manger.Insert to add packet to table.  Callback is set to NULL.  True if added successfull.
bool AddPacket(const AbstractPacket* packet);

//Calls packet_manager.Insert to add packet, callback pair to table.  True if added successfully.
bool LinkCallback(AbstractPacket* packet, const Callback* callback);

//Not implemented
bool LinkQueue(const AbstractPacket* packet, const Queue&lt;AbstractPacket*&gt;* queue);

//Delete the current send_queue and reassign it to the one passed as a parameter.
bool ReplaceSendQueue(const Queue&lt;ObjectStream*&gt;* queue);

//Delete the current recv_queue and reassign it to the one passed as a parameter.
bool ReplaceReceiveQueue(const Queue&lt;AbstractPacket*&gt;* queue);

//Send packet to specified destination.
bool Send(AbstractPacket* packet, uint8_t dest_id) = 0;

//Checks if data was received, if it was, the AbstractPacket is created, the corresponding callback is called, and the abstractpacket is returned.
AbstractPacket* Receive(uint8_t&amp; source_id) = 0;

//Will initialize a connection device
bool InitConnection(transport_protocol_t conn_type, const char* port, const char* address, uint16_t port) = 0;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>576</x>
      <y>2456</y>
      <w>24</w>
      <h>72</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>440</x>
      <y>1712</y>
      <w>280</w>
      <h>384</h>
    </coordinates>
    <panel_attributes>PacketManager
--
//Initializes table to DEFAULT_TABLE_SIZE
PacketManager();

//Initializes table to the parameter value
PacketManager(uint32_t setSize);

//Deletes the table
~PacketManager();

//Inserts 2 parameters as a pair into list
bool Insert(const AbstractPacket* key, const Callback* callback);

//Calls table-&gt;GetCallback, gets the Callback associated with the key, null if key doesn't exist in the table.
Callback* PacketManager::Get(const AbstractPacket&amp; key);

//Calls table-&gt;remove true if removed successfully, false otherwise. 
//WILL FAIL EVERY TIME RIGHT NOW
bool Remove(const AbstractPacket* key);

//NOT IMPLEMENTED
bool Contains(const AbstractPacket&amp; key);

//NOT IMPLEMENTED
//Well, this would certainly be a slow lookup, is it necessary
bool Contains(Callback* call);

//Accessor for size attribute
int32_t GetSize();

//Uses factory to create a new instance of a AbstractPacket subtype of the AbstractPacket saved at the key.  Nullptr if key has no elements or AbstractPacket::Create returns nullptr.
AbstractPacket* ProduceFromId(uint32_t key);

private:
//Used in ProduceFromId method.  Creates instance of AbstractPacket matching subtype of other AbstractPacket.
PacketFactory factory;

//Hashtable storing AbstractPacket and Callback pairs
PacketTable* table;

//Stores amount of pairs in table
//THIS SHOULDN'T EXIST
int32_t size;

//THIS SHOULDN't EXIST
int32_t MaxSize;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>576</x>
      <y>2088</y>
      <w>24</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>608</x>
      <y>1560</y>
      <w>248</w>
      <h>112</h>
    </coordinates>
    <panel_attributes>//Creates new packets of the same sub-type of the AbstractPacket that was passed in.
PacketFactory
--
//Sets id to 1 (no idea what id is supposed to do)
PacketFactory();

//Takes a packet and returns AbstractPacket::create() if that packet was not nullptr.
AbstractPacket* ProduceNewPacket(AbstractPacket* ref);

private:
//No idea what this does.  Is not currently used anywher.
uint32_t id;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>584</x>
      <y>1664</y>
      <w>160</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>180.0;10.0;160.0;30.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>304</x>
      <y>1424</y>
      <w>256</w>
      <h>248</h>
    </coordinates>
    <panel_attributes>//Implementation of a hashtable for AbstractPackets and CallBacks
/PacketTable/
--
//Creates an array of null pointers to Pair arrays that will be the size of the parameter
PacketTable(uint32_t setSize);

//Creates an array of null pointers to Pair arrays that will be the size of DEFAULT_TABLE_SIZE
PacketTable();

//Deletes all the elements inside of the pairs that make up the table and then deletes the table/
~PacketTable();

//Inserts an element into the hashtable.  Will fail if array is full.  Returns true if element was added successfully.
//Called by PacketManager::insert
bool Insert(const AbstractPacket* key, const Callback* callback);

//Gets the element at the hashed key and returns the callback, nullptr if no element exists at the key.
Callback* GetCallback(uint32_t key);

//Gets the element at the hashed key and returns the AbstractPacket, nullptr if no element exists at the key.
AbstractPacket* PacketTable::GetPacket(uint32_t key);

//Pointer to a callback
bool Contains(Callback* call);

//Removes the pair with the matching key from the array.  True on success, false otherwise.
bool Remove(uint32_t key);

//Aquires more memory for the Pairs.  Cannot decrease the size of the memory.
bool Reserve(uint32_t newSize);</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>440</x>
      <y>1664</y>
      <w>152</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>736</x>
      <y>2360</y>
      <w>528</w>
      <h>224</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>640.0;60.0;600.0;10.0;110.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1216</x>
      <y>2408</y>
      <w>312</w>
      <h>288</h>
    </coordinates>
    <panel_attributes>/CommsLink/
--
//Default constructor.
CommsLink();

//Default destructor.
~CommsLink();

//Opens a socket on the machine (address is not used).
bool InitConnection(const char* port = NULL, const char* address, uint32_t baudrate);

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>896</x>
      <y>2872</y>
      <w>264</w>
      <h>272</h>
    </coordinates>
    <panel_attributes>UDPLink
--
//Sets protocol to UDP_LINK
UDPLink();

//Closes local
~UDPLink();
//Initializes local object and binds it to the port parameter on localhost.
bool InitConnection(const char* port = NUll, const char* address = NULL, uint16_t port) = 0;

//Initializes a udp object and adds it to clients. Returns true on successful connection.
bool AddAddress(uint8_t dest_id, const char* address, uint16_t port);

//Removes the client with the dest_id.  True on successful removal.
bool RemoveAddress(uint8_t dest_id);

//Sends data to the client with the dest_id.
bool Send(uint8_t dest_id, int8_t* txData, uint32_t txLength);

//Receives data from all clients.
bool Recv(int8_t* rxData, uint32_t* rxLength);

//Not implemented
void DigestCommand(const char* cmd);

private:
//Doesn't send or receive anything. Initializes and opens the socket.
UDP local;

//Contains all of the clients connected to this socket.
std::map&lt;uint8_t, std::unique_ptr&lt;UDP&gt;&gt; clients;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>2688</y>
      <w>96</w>
      <h>224</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;.</panel_attributes>
    <additional_attributes>100.0;10.0;60.0;200.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1232</x>
      <y>3168</y>
      <w>280</w>
      <h>352</h>
    </coordinates>
    <panel_attributes>SerialLink
--</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1608</x>
      <y>2864</y>
      <w>288</w>
      <h>352</h>
    </coordinates>
    <panel_attributes>XBeeLink
--</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>2688</y>
      <w>96</w>
      <h>496</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;.</panel_attributes>
    <additional_attributes>100.0;10.0;50.0;220.0;10.0;290.0;10.0;540.0;90.0;600.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1520</x>
      <y>2648</y>
      <w>248</w>
      <h>232</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;270.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1360</x>
      <y>2296</y>
      <w>24</w>
      <h>128</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1288</x>
      <y>2240</y>
      <w>168</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>transport_protocol_t
--</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1016</x>
      <y>2848</y>
      <w>24</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>896</x>
      <y>2528</y>
      <w>264</w>
      <h>328</h>
    </coordinates>
    <panel_attributes>UDP
--
//Default constructor.
UDP();

//Move constructor.  Uses copy and swap idiom.
UDP(UDP&amp;&amp; udp);

//Default destructor.
~UDP();

//Calls UdpOpen and binds the socket to the port passed in as a parameter.
bool InitConnection(const char* port = NULL, const char* address = NULL, uint32_t baudrate = 0);

//If the socket is open, create and return a UDP object representing a client with the IP of the parameters passed in.
std::unique_ptr&lt;UDP&gt; Connect(uint8_t dest_id, const char* address = NULL, uint16_t port = 0);

//Sends the data array by using the sendto function in the OS API.
bool Send(uint8_t* tx_data, uint32_t tx_length);

//If data was received, set the rx_data array to the data that was received and return true.
bool Recv(uint8_t* rx_data, uint32_t* rx_length);

//Closes the socket if the socket is not already closed. True on success.
bool Close();

private:
//Initializes UDP socket
UdpOpen(int* fd);

//The socket id, set by UdpOpen.
int fd;

//The IP address of the UDP socket.
socket_t sockaddr;

//The size of sockaddr.socket_address in bytes.
int slen;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>944</x>
      <y>2384</y>
      <w>160</w>
      <h>128</h>
    </coordinates>
    <panel_attributes>socket_t
--
//Integer that holds the socket identication number for calls to winsock.
SOCKET socket;

//Port the socket binds to.
PORT port;

//Holds the destination id of the UDP object.
ID_T id;

//Either SOCKET_OPEN, SOCKET_CLOSED, SOCKET_RESOLVING, SOCKET_CONNECTING, SOCKET_CONNECTED, SOCKET_LISTENING, SOCKET_FAILED
socket_status_t socket_status;

//Holds the information necessary for calls to send and receive.
struct sockaddr_in socket_address;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1016</x>
      <y>2504</y>
      <w>24</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>904</x>
      <y>2024</y>
      <w>288</w>
      <h>224</h>
    </coordinates>
    <panel_attributes>AESEncryption
--</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>712</x>
      <y>2168</y>
      <w>208</w>
      <h>360</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>240.0;10.0;180.0;50.0;10.0;430.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>472</x>
      <y>664</y>
      <w>256</w>
      <h>232</h>
    </coordinates>
    <panel_attributes>//Stores an std::function (typedefed as CallbackFunc) that is invoked by CallFunction
//WARNING: CallbackFunc is a typedef of std::function but takes the appropiate parameters and has the right return type
Callback
--
public:
//Initializes the CallbackFunc to a method that returns -100
Callback();

//Initialize the Callback and set the CallbackFunc to the parameter.  Function must take parameters: const Header&amp; header, AbstractPacket&amp; abPacket, CommNode&amp; node
Callback(CallbackFunc call);

//Default destructor
~Callback();

//Set the CallbackFunc to the parameter, the function must take parameters: const Header&amp; header, AbstractPacket&amp; abPacket, CommNode&amp; node
void SetCallbackListener(CallbackFunc call);

//Called by Comms::CommunicationHandlerRecv and will run the method and will pass in the appropiate parameters
error_t CallFunction(const Header&amp; header, AbstractPacket&amp; abPacket, CommNode&amp; node);

private:
//Remember that CallBackFunc is a typedef for std::function.  Must take the parameters (const Header&amp;, AbstractPacket&amp;, CommNode&amp;)
CallBackFunc callback;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>424</x>
      <y>1376</y>
      <w>24</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>312</x>
      <y>1016</y>
      <w>248</w>
      <h>368</h>
    </coordinates>
    <panel_attributes>PacketHashTable
--
//Creates an array of null pointers to Pair arrays that will be the size of the parameter
PacketTable(uint32_t setSize);

//Creates an array of null pointers to Pair arrays that will be the size of DEFAULT_TABLE_SIZE
PacketTable();

//Deletes all the elements inside of the pairs that make up the table and then deletes the table/
~PacketTable();

//Inserts an element into the hashtable.  Will fail if array is full.  Returns true if element was added successfully.
//Called by PacketManager::insert
bool Insert(const AbstractPacket* key, const Callback* callback);

//Gets the element at the hashed key and returns the callback, nullptr if no element exists at the key.
Callback* GetCallback(uint32_t key);

//Gets the element at the hashed key and returns the AbstractPacket, nullptr if no element exists at the key.
AbstractPacket* PacketTable::GetPacket(uint32_t key);

//Not implemented yet
bool Remove(uint32_t key);

//Not implemented yet
bool Resize(uint32_t newSize);

private:
//Increments i, sets it to 0 if greater than or equal to tableSize.  Called by Insert.
int32_t TraverseIndex(int32_t i);

//Hashes the key and returns an integer between 0 and tableSize (but no equal to tableSize)
uint32_t KeyHash(uint32_t key);

//An array of Pair* with size tableSize.  Where all the elements are inserted, etc.
Pair** table;

//Number of elements in the array.
uint32_t numOfPairs;

//The maximum amount of elements that can be stored in the map before a resize is needed.
uint32_t tableSize;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>248</x>
      <y>896</y>
      <w>200</w>
      <h>136</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0;230.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>424</x>
      <y>888</y>
      <w>200</w>
      <h>144</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>230.0;10.0;200.0;50.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1232</x>
      <y>2832</y>
      <w>280</w>
      <h>312</h>
    </coordinates>
    <panel_attributes>Serial
--
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1360</x>
      <y>3136</y>
      <w>24</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1784</x>
      <y>56</y>
      <w>400</w>
      <h>424</h>
    </coordinates>
    <panel_attributes>marshal
(non class)
namespace comnet::serilization
--
+typedef uint8_t* marshal_t;
+typedef char* string_t;	
--
+uint32_t PackString(string_t data, uint8_t len, marshal_t input);	
+uint32_t UnpackString(string_t data, uint8_t len, marshal_t input);	
+uint32_t PackWideString(std::wstring  &amp;data, uint8_t len, marshal_t input);	
+uint32_t UnpackWideString(std::wstring &amp;data, uint8_t len, marshal_t input);	
+uint32_t PackByte(uint8_t data, marshal_t input);	
+uint8_t UnpackByte(marshal_t input);	
+uint32_t PackUint16(uint16_t data, marshal_t input);	
+uint16_t UnpackUint16(marshal_t input);	
+uint32_t PackInt16(int16_t data, marshal_t input);	
+int16_t UnpackInt16(marshal_t input);	
+uint32_t PackUint32(uint32_t data, marshal_t input);	
+uint32_t UnpackUint32(marshal_t input);	
+uint32_t PackInt32(int32_t data, marshal_t input);	
+int32_t UnpackInt32(marshal_t input);	
+uint32_t PackUint64(uint64_t data, marshal_t input);	
+uint64_t UnpackUint64(marshal_t input);	
+uint32_t PackInt64(int64_t data, marshal_t input);	
+int64_t UnpackInt64(marshal_t input);	
+uint32_t PackReal32(real32_t data, marshal_t input);	
+real32_t UnpackReal32(marshal_t input);	
+uint32_t PackReal64(real64_t data, marshal_t input);	
+real64_t UnpackReal64(marshal_t input);
--
+template &lt;typename T&gt; void SwapEndian(T&amp; pX)
+template &lt;typename T&gt; T SwapEndianCopy(T pX)
+template &lt;typename T&gt; int16_t PackGeneric(T data, marshal_t input)	
+template &lt;typename T&gt; T UnpackGeneric(marshal_t input)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLNote</id>
    <coordinates>
      <x>1784</x>
      <y>0</y>
      <w>104</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>serialization folder
bg=blue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1784</x>
      <y>528</y>
      <w>400</w>
      <h>656</h>
    </coordinates>
    <panel_attributes>ObjectStream
namespace comnet::serilization
--
private:
-marshal_t stream_buffer;
-int32_t curr_pos;
-void PrintErrorUnderFlow();
-void PrintErrorOverFlow();
--
public:
+Header header_packet;
+ObjectStream();
+ObjectStream(ObjectStream&amp;&amp; obj);
+ObjectStream&amp; operator=(ObjectStream&amp;&amp; obj);  
+~ObjectStream();
+int32_t GetPosition() const { return curr_pos; }
+int32_t GetSize() const { return curr_pos; }
+marshal_t GetBuffer() const { return stream_buffer; }
  
  Header&amp; GetHeaderPacket() { return header_packet; } 
//setBuffer will take a pointer to an array of char and its len to become the new stream of data
+void SetBuffer(const char* buffer, int len);
+void SetHeader(Header&amp; header);  
+void SerializeHeader();
+Header DeserializeHeader();
  
//Overloaded input stream operators to put variables into the object stream
+ObjectStream&amp; operator&lt;&lt;(string_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(std::wstring&amp; data);
+ObjectStream&amp; operator&lt;&lt;(std::string&amp; data);
+ObjectStream&amp; operator&lt;&lt;(uint8_t&amp; data);  
+ObjectStream&amp; operator&lt;&lt;(int8_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(uint16_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(int16_t&amp; data);  
+ObjectStream&amp; operator&lt;&lt;(int32_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(uint32_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(int64_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(uint64_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(real32_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(real64_t&amp; data);  

//Overloaded output stream operators to output variables to a variable from the object stream
//string_t (char*) must use malloc when inputing data into new c-string variable
+ObjectStream&amp; operator&gt;&gt;(string_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::wstring&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::string&amp; data);
+ObjectStream&amp; operator&gt;&gt;(uint8_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(int8_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(uint16_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(int16_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(uint32_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(int32_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(uint64_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(int64_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(real32_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(real64_t&amp; data); 
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1216</x>
      <y>56</y>
      <w>400</w>
      <h>192</h>
    </coordinates>
    <panel_attributes>Header
namespace comnet
--
public:
+uint8_t dest_id;
+uint8_t source_id;
+uint16_t msg_len;
+uint16_t msg_id;
+uint8_t source_time_arr[4];
+uint8_t iv[KEY_LENGTH];

+int32_t GetSourceTime() const;
+void SetSourceTime(int32_t source_time);
+static uint32_t Serialize(Header&amp; header, uint8_t* buffer, uint32_t offset);
+static uint32_t Deserialize(Header&amp; header, uint8_t* buffer, uint32_t offset);</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>96</x>
      <y>312</y>
      <w>184</w>
      <h>152</h>
    </coordinates>
    <panel_attributes>Ping
namespace comnet
--
public:
+Ping();
+Ping(std::string num);
+~Ping() { }
+void Pack(ObjectStream&amp; obj);
+void Unpack(ObjectStream&amp; obj);
+AbstractPacket* Create();

+std::string test;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>296</x>
      <y>312</y>
      <w>184</w>
      <h>152</h>
    </coordinates>
    <panel_attributes>Pong
namespace comnet
--
public:
+Pong(char letter);
+~Pong();
+void Pack(ObjectStream&amp; obj);
+void Unpack(ObjectStream&amp; obj);
+ AbstractPacket* Create();

+char letter;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLNote</id>
    <coordinates>
      <x>1216</x>
      <y>8</y>
      <w>112</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>main folder
bg=blue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>224</x>
      <y>456</y>
      <w>24</w>
      <h>96</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;100.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>328</x>
      <y>456</y>
      <w>24</w>
      <h>96</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;100.0;10.0;10.0</additional_attributes>
  </element>
</diagram>
