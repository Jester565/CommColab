<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.2">
  <zoom_level>8</zoom_level>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1224</x>
      <y>1152</y>
      <w>256</w>
      <h>368</h>
    </coordinates>
    <panel_attributes>//Abstract class to be used for determining what data should be sent and what callback to use when received.  Has a unique key to distinguish it from other packets.
AbstractPacket
--
public:
//New instance of AbstractPacket, sets the typeID attribute to the hash of typeIDHashKey
AbstractPacket(const char* typeIDHashKey);

//Accessor for the id of the packet, used to set the msg_id of a header
uint32_t GetID() const;

//Serializes the contents of the packet to the outStream parameter (pure virtual).  Called by Comm::send.
void Pack(ObjectStream&amp; outStream) = 0;

//Parses the contents of the packet from the inStream parameter (pure virtual)
void Unpack(ObjectStream&amp; inStream) = 0;

//Casts AbstractPacket to Type and returns it (return by reference evil?)
static Type&amp; GetValue(AbstractPacket&amp; packet);

//Returns a new instance of some child of AbstractPacket (pure virtual).  Used by PacketFactory.
AbstractPacket* Create() = 0;

//Default destructor
~AbstractPacket();

private:
//Default constructor (maybe this shouldn't exist?)
AbstractPacket();

//Accessed by getID(), set by constructor. Identification number for the packet.
uint32_t type_id;

--

//Call from child's constructor to AbstractPacket's constructor.  Pass in the type of the child and it
//will be converted into a const char* and be passed into AbstractPacket constructor as classname parameter.
CHAIN_ABSPACKET(class_name)

//Example - class Packet : INHERITS_ABSPACKET {};
INHERITS_ABSPACKET

//Defined as the name of the class representing the abstractpacket (so in this case comnet::AbstractPacket)
ABSPACKET</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>0</x>
      <y>2192</y>
      <w>248</w>
      <h>408</h>
    </coordinates>
    <panel_attributes>api.h
--

--
//Hexidecmial representatoin of the minimum version of the library
_COMNET_MINIMUM_API_VERSION_

//Hexidecimal representation of the last version of the library that has the same method names (no deprecated methods)
_COMNET_COMPATIBLE_API_VERSOIN_

//Hexidecimal representation of the current version of the library (Should be greater than COMENT_COMPATIBLE_API_VERSION_ and COMNET_MINIMUM_API_VERSION_
_COMNET_CURRENT_API_VERSION_

//I still don't really know what this does... you pass it one of the API_VERSOIN defines and it just gives you the hexideceimal (so it just returns the parameter you passed it...)
obtain_api_version(_api_version)

//Put before classes to denote what part of the API they are (public in this case).  Never get rid of this define or the program won't compile.
_COMNET_PUBLIC_API_

//Put before classes to denote what part of the API they are (general in this case).  Never get rid of this define or the program won't compile.
_COMNET_API_

//Put before classes to denote what part of the API they are (private in this case).  Never get rid of this define or the program won't compile.
_COMNET_API_PRIVATE_

//Not implemented anywhere yet.  Denotes how much implementers of the library will have to see the classes 0 means they will probably never see it and 5 means they will see it.  Just a guess though.
_COMNET_API_LEVEL_(UNKNOWN, 0, 1, 2,3,4,5)_

//Replace for class so that the class behaving as an interface is more clear.  Not implemented anywhere.
_COMNET_INTERFACE_

//Replace for class so that the class behaving as an abstract class is more clear.  Not implemented anywhere.
_COMNET_ABSTRACT_

//Replace for class so that the class behaving as a normal class is more clear.  Not implemented anywhere.
_CLASS_

//Retunrs the value of _COMNET_CURRENT_API_VERSION_
_current_api_version obtain_api_version(_COMNET_CURRENT_API_VERSION_)

//This define is put in classes that should be apart of the DLL.  However, when in static library mode, this is left blank.
COMM_EXPORT

//Not sure what the purpose of this is.  Usually the linker will figure out dll imports for you.
COMM_IMPORT

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>48</x>
      <y>1968</y>
      <w>152</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>arch.h
--

--
//Set to one of the defines below based on macro detection of which OS the library is being built on
COM_TARGET_OS

COM_OS_UNKNOWN

COM_OS_WINDOWS

COM_OS_LINUX

//Not used
COM_OS_QX

//Not used
COM_OS_BSD</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>112</x>
      <y>2160</y>
      <w>24</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1488</x>
      <y>3008</y>
      <w>328</w>
      <h>304</h>
    </coordinates>
    <panel_attributes>Comms
--
private:
-CommMutex send_mutex;
-CommMutex recv_mutex;
-CommMutex console_mutex;
-CommConditionVariable comm_cond_var_send;
-uint32_t rx_length;
-CommThread comm_thread_send;
-CommThread comm_thread_recv;
-CommThread console_thread;
-void CommunicationHandlerSend();
-void CommunicationHandlerRecv();
-CommsLink *conn_layer;
-encryption::CommEncryptor encrypt;
-encryption::CommDecryptor decrypt;
-std::shared_ptr &lt;ConnectionStateManager&gt; conStateManager;

public:		
+Comms(uint8_t platform_id);
+~Comms();
+bool LoadKey(char* key);
+bool LoadKeyFromFile(char*keyFileName);</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1456</x>
      <y>2600</y>
      <w>544</w>
      <h>336</h>
    </coordinates>
    <panel_attributes>//Abstract class that will allow for easy adjustments in node changing and style.
/CommsNode/
--
//Initially 0, is incremented every time a CommNode is created so the value of unique_id can be set to this value.
static uint16_t number_of_nodes;

//Sets unique_id to number_of_nodes, increments number_of_nodes.  Sets attributes to default.
CommNode();

//Sets node_id to the parameter platform_id (this name is a bit confusing to me).
//Sets unique_id to number_of_nodes, increments number_of_nodes.  Sets attributes to default.
CommNode(const uint32_t platform_id);

//Delets the recv_queue and send_queue
//MEMEORY LEAK: Elements inside the queues are not deleted! (Not too sure about this yet)
~CommNode();

//Calls packet_manger.Insert to add packet to table.  Callback is set to NULL.  True if added successfull.
bool AddPacket(const AbstractPacket* packet);

//Calls packet_manager.Insert to add packet, callback pair to table.  True if added successfully.
bool LinkCallback(AbstractPacket* packet, const Callback* callback);

//Not implemented
bool LinkQueue(const AbstractPacket* packet, const Queue&lt;AbstractPacket*&gt;* queue);

//Delete the current send_queue and reassign it to the one passed as a parameter.
bool ReplaceSendQueue(const Queue&lt;ObjectStream*&gt;* queue);

//Delete the current recv_queue and reassign it to the one passed as a parameter.
bool ReplaceReceiveQueue(const Queue&lt;AbstractPacket*&gt;* queue);

//Send packet to specified destination.
bool Send(AbstractPacket* packet, uint8_t dest_id) = 0;

//Checks if data was received, if it was, the AbstractPacket is created, the corresponding callback is called, and the abstractpacket is returned.
AbstractPacket* Receive(uint8_t&amp; source_id) = 0;

//Will initialize a connection device
bool InitConnection(transport_protocol_t conn_type, const char* port, const char* address, uint16_t port) = 0;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1520</x>
      <y>2184</y>
      <w>328</w>
      <h>384</h>
    </coordinates>
    <panel_attributes>PacketManager
--
//Initializes table to DEFAULT_TABLE_SIZE
PacketManager();

//Initializes table to the parameter value
PacketManager(uint32_t setSize);

//Deletes the table
~PacketManager();

//Inserts 2 parameters as a pair into list
bool Insert(const AbstractPacket* key, const Callback* callback);

//Calls table-&gt;GetCallback, gets the Callback associated with the key, null if key doesn't exist in the table.
Callback* PacketManager::Get(const AbstractPacket&amp; key);

//Calls table-&gt;remove true if removed successfully, false otherwise. 
//WILL FAIL EVERY TIME RIGHT NOW
bool Remove(const AbstractPacket* key);

//NOT IMPLEMENTED
bool Contains(const AbstractPacket&amp; key);

//NOT IMPLEMENTED
//Well, this would certainly be a slow lookup, is it necessary
bool Contains(Callback* call);

//Accessor for size attribute
int32_t GetSize();

//Uses factory to create a new instance of a AbstractPacket subtype of the AbstractPacket saved at the key.  Nullptr if key has no elements or AbstractPacket::Create returns nullptr.
AbstractPacket* ProduceFromId(uint32_t key);

private:
//Used in ProduceFromId method.  Creates instance of AbstractPacket matching subtype of other AbstractPacket.
PacketFactory factory;

//Hashtable storing AbstractPacket and Callback pairs
PacketTable* table;

//Stores amount of pairs in table
//THIS SHOULDN'T EXIST
int32_t size;

//THIS SHOULDN't EXIST
int32_t MaxSize;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1608</x>
      <y>2032</y>
      <w>296</w>
      <h>112</h>
    </coordinates>
    <panel_attributes>//Creates new packets of the same sub-type of the AbstractPacket that was passed in.
PacketFactory
--
//Sets id to 1 (no idea what id is supposed to do)
PacketFactory();

//Takes a packet and returns AbstractPacket::create() if that packet was not nullptr.
AbstractPacket* ProduceNewPacket(AbstractPacket* ref);

private:
//No idea what this does.  Is not currently used anywher.
uint32_t id;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1800</x>
      <y>1704</y>
      <w>328</w>
      <h>248</h>
    </coordinates>
    <panel_attributes>//Implementation of a hashtable for AbstractPackets and CallBacks
/PacketTable/
--
//Creates an array of null pointers to Pair arrays that will be the size of the parameter
PacketTable(uint32_t setSize);

//Creates an array of null pointers to Pair arrays that will be the size of DEFAULT_TABLE_SIZE
PacketTable();

//Deletes all the elements inside of the pairs that make up the table and then deletes the table/
~PacketTable();

//Inserts an element into the hashtable.  Will fail if array is full.  Returns true if element was added successfully.
//Called by PacketManager::insert
bool Insert(const AbstractPacket* key, const Callback* callback);

//Gets the element at the hashed key and returns the callback, nullptr if no element exists at the key.
Callback* GetCallback(uint32_t key);

//Gets the element at the hashed key and returns the AbstractPacket, nullptr if no element exists at the key.
AbstractPacket* PacketTable::GetPacket(uint32_t key);

//Pointer to a callback
bool Contains(Callback* call);

//Removes the pair with the matching key from the array.  True on success, false otherwise.
bool Remove(uint32_t key);

//Aquires more memory for the Pairs.  Cannot decrease the size of the memory.
bool Reserve(uint32_t newSize);</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2288</x>
      <y>2984</y>
      <w>440</w>
      <h>184</h>
    </coordinates>
    <panel_attributes>/CommsLink/
--
//Default constructor.
CommsLink();
//Default destructor.
virtual ~CommsLink();

//Opens a socket on the machine (address is not used).
virtual bool InitConnection(const char* port, const char* address, uint32_t baudrate) = 0;
virtual bool AddAddress(uint8_t dest_id, const char* addreses, uint16_t port) = 0;
virtual bool RemoveAddress(uint8_t dest_id) = 0;
virtual bool Send(uint8_t dest_id, uint8_t* tx_data, uint32_t tx_length) = 0;
virtual bool Recv(uint8_t* rx_data, uint32_t* rx_length) = 0;
virtual void DigestCommand(const char* cmd) = 0;
transport_protocol_t GetPrtocol();
--
transport_protocol_t protocol;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1752</x>
      <y>3376</y>
      <w>408</w>
      <h>272</h>
    </coordinates>
    <panel_attributes>UDPLink
--
//Sets protocol to UDP_LINK
UDPLink();
//Closes local
~UDPLink();
//Initializes local object and binds it to the port parameter on localhost.
bool InitConnection(const char* port, const char* address, uint16_t port) override;
//Initializes a udp object and adds it to clients. Returns true on successful connection.
bool AddAddress(uint8_t dest_id, const char* address, uint16_t port) override;
//Removes the client with the dest_id.  True on successful removal.
bool RemoveAddress(uint8_t dest_id) override;
//Sends data to the client with the dest_id.
bool Send(uint8_t dest_id, int8_t* txData, uint32_t txLength) override;
//Receives data from all clients.
bool Recv(int8_t* rxData, uint32_t* rxLength) override;

//Not implemented
void DigestCommand(const char* cmd);

private:
//Doesn't send or receive anything. Initializes and opens the socket.
UDP local;
//Contains all of the clients connected to this socket.
std::map&lt;uint8_t, std::unique_ptr&lt;UDP&gt;&gt; clients;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2176</x>
      <y>3664</y>
      <w>432</w>
      <h>192</h>
    </coordinates>
    <panel_attributes>SerialLink
--
SerialLink();
~SerialLink();

bool InitConnection(const char* port, const char* address, uint32_t baudrate) override;
bool AddAddress(uint8_t dest_id, const char* address, uint16_t port) override;
bool RemoveAddress(uint8_t dest_id) override;
bool Send(uint8_t dest_id, uint8_t* tx_data, uint32_t tx_length) override;
bool Recv(uint8_t* rx_data, uint32_t* rx_length) override;

void DigestCommand(const char* cmd) override;
--
Serial* local;
LIst &lt;SerialConn*&gt;* connections;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2616</x>
      <y>3432</y>
      <w>288</w>
      <h>352</h>
    </coordinates>
    <panel_attributes>XBeeLink
--</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2384</x>
      <y>2864</y>
      <w>168</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>transport_protocol_t
--</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1848</x>
      <y>3072</y>
      <w>424</w>
      <h>248</h>
    </coordinates>
    <panel_attributes>UDP
--
//Default constructor.
UDP();

//Move constructor.  Uses copy and swap idiom.
UDP(UDP&amp;&amp; udp);

//Default destructor.
~UDP();

//Calls UdpOpen and binds the socket to the port passed in as a parameter.
bool InitConnection(const char* port, const char* address, uint32_t baudrate);
//If the socket is open, create and return a UDP object representing a client with the IP of the parameters passed in.
std::unique_ptr&lt;UDP&gt; Connect(uint8_t dest_id, const char* address, uint16_t port);
//Sends the data array by using the sendto function in the OS API.
bool Send(uint8_t* tx_data, uint32_t tx_length);
//If data was received, set the rx_data array to the data that was received and return true.
bool Recv(uint8_t* rx_data, uint32_t* rx_length);
socket_t&amp; GetSocket();
//Closes the socket if the socket is not already closed. True on success.
bool Close();
--
//Initializes UDP socket
UdpOpen(int* fd);
//The socket id, set by UdpOpen.
int fd;
//The IP address of the UDP socket.
socket_t sockaddr;
//The size of sockaddr.socket_address in bytes.
int slen;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2032</x>
      <y>2952</y>
      <w>192</w>
      <h>96</h>
    </coordinates>
    <panel_attributes>socket_t
--
//Integer that holds the socket identication number for calls to winsock.
SOCKET socket;
//Port the socket binds to.
PORT port;
//Holds the destination id of the UDP object.
ID_T id;
//Either SOCKET_OPEN, SOCKET_CLOSED, SOCKET_RESOLVING, SOCKET_CONNECTING, SOCKET_CONNECTED, SOCKET_LISTENING, SOCKET_FAILED
socket_status_t socket_status;
//Holds the information necessary for calls to send and receive.
struct sockaddr_in socket_address;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1960</x>
      <y>2016</y>
      <w>360</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>CommEncryptor 
--
-std::shared_ptr&lt;EncryptionInterface&gt; encryption;
-CommDecryptor* decryptor;
-CryptProtocol protocol;
-friend class CommDecryptor;
--
-COMM_DISALLOW_COPYING(CommEncryptor)
+CommEncryptor();
+CommEncryptor(CryptProtocol proto);
+CommEncryptor(CryptProtocol proto, CommDecryptor* decryptor);
+CommEncryptor(CommEncryptor&amp;&amp; encrypt);
+CommEncryptor&amp; operator=(CommEncryptor&amp;&amp; encrypt);
+~CommEncryptor();
+uint8_t LoadKey(char* key);
+uint8_t LoadKeyFromFile(char* filename_key);
+int32_t Encrypt(comnet::serialization::ObjectStream* obj);
+CommDecryptor* GetDecryptor() { return decryptor; }
+void LinkDecryptor(CommDecryptor* decrypt) { decryptor = decrypt; }
+CryptProtocol GetEncryptionType() { return protocol; }
+bool KeyIsLoaded();
-void Setup();</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1504</x>
      <y>1304</y>
      <w>472</w>
      <h>216</h>
    </coordinates>
    <panel_attributes>//Stores an std::function (typedefed as CallbackFunc) that is invoked by CallFunction
//WARNING: CallbackFunc is a typedef of std::function but takes the appropiate parameters and has the right return type
Callback
--
public:
//Initializes the CallbackFunc to a method that returns -100
Callback();

//Initialize the Callback and set the CallbackFunc to the parameter.  Function must take parameters: const Header&amp; header, AbstractPacket&amp; abPacket, CommNode&amp; node
Callback(CallbackFunc call);

//Default destructor
~Callback();

//Set the CallbackFunc to the parameter, the function must take parameters: const Header&amp; header, AbstractPacket&amp; abPacket, CommNode&amp; node
void SetCallbackListener(CallbackFunc call);

//Called by Comms::CommunicationHandlerRecv and will run the method and will pass in the appropiate parameters
error_t CallFunction(const Header&amp; header, AbstractPacket&amp; abPacket, CommNode&amp; node);

private:
//Remember that CallBackFunc is a typedef for std::function.  Must take the parameters (const Header&amp;, AbstractPacket&amp;, CommNode&amp;)
CallBackFunc callback;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1432</x>
      <y>1608</y>
      <w>328</w>
      <h>368</h>
    </coordinates>
    <panel_attributes>PacketHashTable
--
//Creates an array of null pointers to Pair arrays that will be the size of the parameter
PacketTable(uint32_t setSize);

//Creates an array of null pointers to Pair arrays that will be the size of DEFAULT_TABLE_SIZE
PacketTable();

//Deletes all the elements inside of the pairs that make up the table and then deletes the table/
~PacketTable();

//Inserts an element into the hashtable.  Will fail if array is full.  Returns true if element was added successfully.
//Called by PacketManager::insert
bool Insert(const AbstractPacket* key, const Callback* callback);

//Gets the element at the hashed key and returns the callback, nullptr if no element exists at the key.
Callback* GetCallback(uint32_t key);

//Gets the element at the hashed key and returns the AbstractPacket, nullptr if no element exists at the key.
AbstractPacket* PacketTable::GetPacket(uint32_t key);

//Not implemented yet
bool Remove(uint32_t key);

//Not implemented yet
bool Resize(uint32_t newSize);

private:
//Increments i, sets it to 0 if greater than or equal to tableSize.  Called by Insert.
int32_t TraverseIndex(int32_t i);

//Hashes the key and returns an integer between 0 and tableSize (but no equal to tableSize)
uint32_t KeyHash(uint32_t key);

//An array of Pair* with size tableSize.  Where all the elements are inserted, etc.
Pair** table;

//Number of elements in the array.
uint32_t numOfPairs;

//The maximum amount of elements that can be stored in the map before a resize is needed.
uint32_t tableSize;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2208</x>
      <y>3376</y>
      <w>400</w>
      <h>248</h>
    </coordinates>
    <panel_attributes>Serial
--
Serial();
Serial(uint32_t id);
~Serial();

bool OpenConnection(const char* port, const char* address, uint32_t baudrate);
bool Send(uint8_t dest_id, uint8_t* tx_data, uint32_t tx_length);
bool Recv(uint8_t* rx_data, uint32_t* rx_length);
serial_status GetStatus();
bool CloseSerialPort();
serial_t&amp; GetSerialPort();
void SetId(uint32_t id);
--
int32_t id;
serial_t h_serial;
bool connection_established;
Parser parser;
uint8_t buffer_recv[];
uint8_t buffer_send[];</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2824</x>
      <y>24</y>
      <w>400</w>
      <h>408</h>
    </coordinates>
    <panel_attributes>marshal
(non class)
--
+typedef uint8_t* marshal_t;
+typedef char* string_t;	
--
+uint32_t PackString(string_t data, uint8_t len, marshal_t input);	
+uint32_t UnpackString(string_t data, uint8_t len, marshal_t input);	
+uint32_t PackWideString(std::wstring  &amp;data, uint8_t len, marshal_t input);	
+uint32_t UnpackWideString(std::wstring &amp;data, uint8_t len, marshal_t input);	
+uint32_t PackByte(uint8_t data, marshal_t input);	
+uint8_t UnpackByte(marshal_t input);	
+uint32_t PackUint16(uint16_t data, marshal_t input);	
+uint16_t UnpackUint16(marshal_t input);	
+uint32_t PackInt16(int16_t data, marshal_t input);	
+int16_t UnpackInt16(marshal_t input);	
+uint32_t PackUint32(uint32_t data, marshal_t input);	
+uint32_t UnpackUint32(marshal_t input);	
+uint32_t PackInt32(int32_t data, marshal_t input);	
+int32_t UnpackInt32(marshal_t input);	
+uint32_t PackUint64(uint64_t data, marshal_t input);	
+uint64_t UnpackUint64(marshal_t input);	
+uint32_t PackInt64(int64_t data, marshal_t input);	
+int64_t UnpackInt64(marshal_t input);	
+uint32_t PackReal32(real32_t data, marshal_t input);	
+real32_t UnpackReal32(marshal_t input);	
+uint32_t PackReal64(real64_t data, marshal_t input);	
+real64_t UnpackReal64(marshal_t input);
--
+template &lt;typename T&gt; void SwapEndian(T&amp; pX)
+template &lt;typename T&gt; T SwapEndianCopy(T pX)
+template &lt;typename T&gt; int16_t PackGeneric(T data, marshal_t input)	
+template &lt;typename T&gt; T UnpackGeneric(marshal_t input)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2824</x>
      <y>456</y>
      <w>384</w>
      <h>1456</h>
    </coordinates>
    <panel_attributes>ObjectStream
--
-marshal_t stream_buffer;
-int32_t curr_pos;
-void PrintErrorUnderFlow();
-void PrintErrorOverFlow();
--
+Header header_packet;
+ObjectStream();
+ObjectStream(ObjectStream&amp;&amp; obj);
+ObjectStream&amp; operator=(ObjectStream&amp;&amp; obj);  
+~ObjectStream();
+int32_t GetPosition() const { return curr_pos; }
+int32_t GetSize() const { return curr_pos; }
+marshal_t GetBuffer() const { return stream_buffer; }
+Header&amp; GetHeaderPacket() { return header_packet; } 
+void SetBuffer(const char* buffer, int len);
+void SetHeader(Header&amp; header);  
+void SerializeHeader();
+Header DeserializeHeader();

+ObjectStream&amp; operator&lt;&lt;(string_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(std::wstring&amp; data);
+ObjectStream&amp; operator&lt;&lt;(std::string&amp; data);
+ObjectStream&amp; operator&lt;&lt;(uint8_t&amp; data);  
+ObjectStream&amp; operator&lt;&lt;(int8_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(uint16_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(int16_t&amp; data);  
+ObjectStream&amp; operator&lt;&lt;(int32_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(uint32_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(int64_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(uint64_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(real32_t&amp; data);
+ObjectStream&amp; operator&lt;&lt;(real64_t&amp; data);  
+ObjectStream&amp; operator&lt;&lt;(ObjSerializable&amp; data);

//Overloaded output stream operators to output variables to a variable from the object stream
//string_t (char*) must use malloc when inputing data into new c-string variable
+ObjectStream&amp; operator&gt;&gt;(string_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::wstring&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::string&amp; data);
+ObjectStream&amp; operator&gt;&gt;(uint8_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(int8_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(uint16_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(int16_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(uint32_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(int32_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(uint64_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(int64_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(real32_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(real64_t&amp; data);
+ObjectStream&amp; operator&gt;&gt;(ObjSerializable&amp; data);

+ObjectStream&amp; operater&lt;&lt;(const std::vector&lt;T&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::vector&lt;T&gt;&amp; data);
+ObjectStream&amp; operater&lt;&lt;(const std::vector&lt;T*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::vector&lt;T*&gt;&amp; data);

+ObjectStream&amp; operator&lt;&lt;(const std::list&lt;T&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::list&lt;T&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::list&lt;T*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::list&lt;T*&gt;&amp; data);

+ObjectStream&amp; operator&lt;&lt;(const std::set&lt;T&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::set&lt;T&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::set&lt;T*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::set&lt;T*&gt;&amp; data);

+ObjectStream&amp; operator&lt;&lt;(const std::multiset&lt;T&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::multiset&lt;T&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::multiset&lt;T*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::multiset&lt;T*&gt;&amp; data);

+ObjectStream&amp; operator&lt;&lt;(const std::unordered_set&lt;T&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_set&lt;T&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::unordered_set&lt;T*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_set&lt;T*&gt;&amp; data);

+ObjectStream&amp; operator&lt;&lt;(const std::unordered_multiset&lt;T&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_multiset&lt;T&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::unordered_multiset&lt;T*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_multiset&lt;T*&gt;&amp; data);

+ObjectStream&amp; operator&lt;&lt;(const std::map&lt;T,D&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::map&lt;T,D&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::map&lt;T*,D&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::map&lt;T*,D&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::map&lt;T,D*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::map&lt;T,D*&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::map&lt;T*,D*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::map&lt;T*,D*&gt;&amp; data);

+ObjectStream&amp; operator&lt;&lt;(const std::multimap&lt;T,D&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::multimap&lt;T,D&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::multimap&lt;T,D*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::multimap&lt;T,D*&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::multimap&lt;T*,D&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::multimap&lt;T*,D&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::multimap&lt;T*,D*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::multimap&lt;T*,D*&gt;&amp; data);

+ObjectStream&amp; operator&lt;&lt;(const std::unordered_map&lt;T,D&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_map&lt;T,D&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::unordered_map&lt;T*,D&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_map&lt;T*,D&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::unordered_map&lt;T,D*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_map&lt;T,D*&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::unordered_map&lt;T*,D*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_map&lt;T*,D*&gt;&amp; data);

+ObjectStream&amp; operator&lt;&lt;(const std::unordered_multimap&lt;T,D&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_multimap&lt;T,D&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::unordered_multimap&lt;T,D*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_multimap&lt;T,D*&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::unordered_multimap&lt;T*,D&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_multimap&lt;T*,D&gt;&amp; data);
+ObjectStream&amp; operator&lt;&lt;(const std::unordered_multimap&lt;T*,D*&gt;&amp; data);
+ObjectStream&amp; operator&gt;&gt;(std::unordered_multimap&lt;T*,D*&gt;&amp; data);</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2168</x>
      <y>1064</y>
      <w>400</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>Header
--
+uint8_t dest_id;
+uint8_t source_id;
+uint16_t msg_len;
+uint16_t msg_id;
+uint8_t source_time_arr[4];
+uint8_t iv[KEY_LENGTH];
--
+int32_t GetSourceTime() const;
+void SetSourceTime(int32_t source_time);
+static uint32_t Serialize(Header&amp; header, uint8_t* buffer, uint32_t offset);
+static uint32_t Deserialize(Header&amp; header, uint8_t* buffer, uint32_t offset);</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1176</x>
      <y>960</y>
      <w>184</w>
      <h>152</h>
    </coordinates>
    <panel_attributes>Ping
--
+std::string test;
--
+Ping();
+Ping(std::string num);
+~Ping() { }
+void Pack(ObjectStream&amp; obj);
+void Unpack(ObjectStream&amp; obj);
+AbstractPacket* Create();

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1376</x>
      <y>960</y>
      <w>184</w>
      <h>152</h>
    </coordinates>
    <panel_attributes>Pong
--
+char letter;
--
+Pong(char letter);
+~Pong();
+void Pack(ObjectStream&amp; obj);
+void Unpack(ObjectStream&amp; obj);
+AbstractPacket* Create();
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2728</x>
      <y>2016</y>
      <w>432</w>
      <h>152</h>
    </coordinates>
    <panel_attributes>&lt;&lt;Interface&gt;&gt;
EncryptionInterface 
namespace comnet::encryption
--
public:
+virtual ~EncryptionInterface();
+virtual uint8_t LoadKey(char* key) = 0;
+virtual uint8_t LoadKeyFromFile(char*keyFileName) = 0;
+virtual int32_t Encrypt(uint8_t* buffer, uint32_t length, uint8_t iv[BLOCK_SIZE]) = 0;
+virtual int32_t Decrypt(uint8_t* buffer, uint32_t length, uint8_t iv[BLOCK_SIZE]) = 0;
+virtual uint8_t GenerateRandomIV(uint8_t * buffer, uint32_t length) = 0;
+virtual bool KeyIsLoaded() = 0;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2336</x>
      <y>2016</y>
      <w>352</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>CommDecryptor
--
- std::shared_ptr&lt;EncryptionInterface&gt; encryption;
- CommEncryptor* encryptor;
-CryptProtocol protocol;
- friend class CommEncryptor;
--
-COMM_DISALLOW_COPYING(CommDecryptor);
+CommDecryptor();
+CommDecryptor(CryptProtocol proto);
+CommDecryptor(CryptProtocol proto, CommEncryptor* encryptor);
+CommDecryptor(CommDecryptor&amp;&amp; decrypt);
+CommDecryptor&amp; operator=(CommDecryptor&amp;&amp; decrypt);
+~CommDecryptor();
+uint8_t LoadKey(char* key);
+uint8_t LoadKeyFromFile(char* filename_key);
+int32_t Decrypt(comnet::serialization::ObjectStream* obj);
+CommEncryptor* GetEncryptor() { return encryptor; }
+void LinkEncryptor
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLPackage</id>
    <coordinates>
      <x>2800</x>
      <y>0</y>
      <w>736</w>
      <h>1944</h>
    </coordinates>
    <panel_attributes>Serilization
--
bg=orange


</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLPackage</id>
    <coordinates>
      <x>1944</x>
      <y>1968</y>
      <w>1256</w>
      <h>600</h>
    </coordinates>
    <panel_attributes>Encryption
--
bg=orange</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2336</x>
      <y>2352</y>
      <w>352</w>
      <h>176</h>
    </coordinates>
    <panel_attributes>AesEncryption
--
-CryptoPP::SecByteBlock sec_key;
-static const int RANDOM_GEN_MIN;
-static const int RANDOM_GEN_MAX;
--
+AesEncryption();
+~AesEncryption();
+uint8_t LoadKey(char* key) override;
+uint8_t LoadKeyFromFile(char*keyFileName) override;
+int32_t Encrypt(uint8_t* buffer, uint32_t length, uint8_t iv[BLOCK_SIZE]) override;
+int32_t Decrypt(uint8_t* buffer, uint32_t length, uint8_t iv[BLOCK_SIZE]) override;
+uint8_t GenerateRandomIV(uint8_t * buffer, uint32_t length) override;
+bool KeyIsLoaded() override { return !sec_key.empty(); }
layer=1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2096</x>
      <y>2288</y>
      <w>288</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>340.0;80.0;340.0;30.0;10.0;30.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2480</x>
      <y>2248</y>
      <w>24</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;130.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2680</x>
      <y>2160</y>
      <w>112</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>120.0;10.0;120.0;280.0;10.0;280.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1968</x>
      <y>2352</y>
      <w>256</w>
      <h>112</h>
    </coordinates>
    <panel_attributes>CommRandom
--
-std::mt19937 randomGenerator;
-std::uniform_int_distribution&lt;int&gt; intDistribution;
--
+CommRandom(int min, int max);
+~CommRandom();
+uint8_t RandomUint8();
+int32_t RandomInt32();

layer=1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2216</x>
      <y>2416</y>
      <w>136</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=&lt;.
&lt;&lt;uses&gt;&gt;</panel_attributes>
    <additional_attributes>10.0;20.0;150.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1808</x>
      <y>2520</y>
      <w>632</w>
      <h>512</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;620.0;280.0;530.0;280.0;120.0;770.0;120.0;770.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1808</x>
      <y>2808</y>
      <w>568</w>
      <h>224</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;260.0;280.0;170.0;280.0;10.0;630.0;10.0;690.0;220.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1560</x>
      <y>1968</y>
      <w>24</w>
      <h>232</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;270.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1752</x>
      <y>1816</y>
      <w>64</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1480</x>
      <y>1512</y>
      <w>88</w>
      <h>112</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;120.0;10.0;60.0;90.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1424</x>
      <y>1512</y>
      <w>80</w>
      <h>112</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>80.0;120.0;80.0;60.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1288</x>
      <y>1104</y>
      <w>24</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;60.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1408</x>
      <y>1104</y>
      <w>24</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;60.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1672</x>
      <y>2560</y>
      <w>24</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1640</x>
      <y>2928</y>
      <w>24</w>
      <h>96</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;100.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2456</x>
      <y>2920</y>
      <w>56</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=&lt;.
&lt;&lt;uses&gt;&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2720</x>
      <y>3160</y>
      <w>232</w>
      <h>288</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;40.0;270.0;260.0;220.0;340.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2184</x>
      <y>3160</y>
      <w>160</w>
      <h>520</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>180.0;10.0;130.0;80.0;130.0;240.0;10.0;260.0;10.0;600.0;180.0;630.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2152</x>
      <y>3160</y>
      <w>192</w>
      <h>272</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>220.0;10.0;170.0;80.0;170.0;240.0;50.0;260.0;10.0;320.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1944</x>
      <y>3312</y>
      <w>24</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;80.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2120</x>
      <y>3040</y>
      <w>24</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;40.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2456</x>
      <y>3616</y>
      <w>24</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;60.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1728</x>
      <y>2136</y>
      <w>24</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;60.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>880</x>
      <y>2160</y>
      <w>464</w>
      <h>648</h>
    </coordinates>
    <panel_attributes>ConnectionStateManager
--
static bool ConStateEnabled;

error_t CheckConnectRequestCallback(...);
error_t CheckConnectReplyCallback(...);

ConnectionStateManager(comnet::Comms* owner);

void LinkCallbacks();
bool Run();
void Stop();

void AddConState(uint8_t nodeID);
void RemoveConState(uint8_t nodeID);

void UpdatePing(uint8_t nodeID, int32_t time);
int16_t GetPing(uint8_t nodeID);
bool IsActive();
bool IsConnected();

void ResetSendTime(uint8_t nodeID);
bool ReadyToSendCheckConnectReply(uint8_t nodeID);

void SyncTime(uint8_t nodeID, int32_t timeOff);
void CheckResync(uint8_t nodeID, int64_t unixHighResTimeDif);

~ConnectionStateManager();
--
void ConStateUpdateHandler();
comnet::architecture::os::CommThread* conStateUpdateThread;
comnet::architecture::os::CommConditionVariable conStateHandlerCV;
bool running;
CommMutex runningMutex;
void SendCheckConReq(uint8_t nodeID);

void TransferToActiveConStates(std::list&lt;ConnectionState&gt;::iterator it);
std::list &lt;ConnectionState&gt; activeConStates;
comnet::architecture::os::CommMutex activeConStatesMutex;

void TransferToInactiveConStates(std::list&lt;ConnectionState&gt;::iterator it);
std::list&lt;ConnectionState&gt; inactiveConStates;
CommMutex inactiveConStatesMutex;

std::unordered_map &lt;uint8_t, std::list&lt;ConnectionState&gt;::iterator&gt; destConStateMap;
comnet::architecture::os::CommMutex destConStateMapMutex;

std::shared_ptr&lt;TimeSyncManager&gt; syncManager;
CheckConnectRequest* checkConRequestPack;
CheckConnectReply* checkConReplyPack;
Comms* owner'</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>400</x>
      <y>2160</y>
      <w>432</w>
      <h>424</h>
    </coordinates>
    <panel_attributes>TimeSyncManager
--
error_t TimeSyncRequestCallback(...);
error_t TimeSyncReplyCallback(...);

SyncManager(comnet::Comms* owner);

void LinkCallbacks();
bool Run();
void Stop();

void AddUnsyncedConState(ConnectionState* conState);
void RemoveUnsyncedConState(ConnectionState* conState);

void SyncTime(ConnetionState* conState, int32_t time);
void CheckResync(ConnectionState* conState, int64_t time);

~SyncManager();
--
void SyncUpdateHandler();

void SendSyncRequest(uint8_t nodeID);

std::list&lt;ConnectionState*&gt; unsyncedPingers;

comnet::architecture::os::CommThread* syncUpdateThread;
bool awake;
bool running;

TimeSyncRequestPacket* syncRequestPacket;
TimeSyncReplyPacket* syncReplyPacket;

Comms* owner;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>824</x>
      <y>2368</y>
      <w>72</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>928</x>
      <y>2848</y>
      <w>368</w>
      <h>784</h>
    </coordinates>
    <panel_attributes>ConnectionState
--
static const int32_t MAX_UNIX_HIGHRES_TIME_DIF;
static const uint32_t CHECK_CONNECT_REQUEST_SEND_DELAY;
static onst uint32_t CHECK_CONNECT_REQUEST_RESEND_DELAY;
static const uint32_t CHECK_CONNECT_REPLY_SEND_DELAY;
static const uint32_t NUM_SYNC_REPLIES_TO_SYNC;
static const uint32_t SYNC_REQUEST_SEND_DELAY;
static const uint32_t MAX_CHECK_CONNECT_REQUESTS;
static const uint32_t PING_UNKOWN;
static comnet::constate::TimePoint GetNow();

ConnectionState(uint8_t nodeID);

uint8_t GetNodeID();

void ResetSyncRequestSentTime();
uint32_t GetTimeUntilSendSyncRequest();

void ResetCheckConnectRequestSentTimeToSend();
void ResetCheckConnectRequestSentTimeToResend();
uint32_t GetTimeUntilSendCheckConnectRequest();
bool IsInactive();
bool IsConnected();

void ResetCheckConnectReplySentTime();
uint32_t GetTimeUntilSendCheckConnectReply();

bool IsResyncRequired(int64_t unixTime);
void Resync();
void SetUnixHighResTimeDif(int64_t unixHighResTimeDif);

void SyncTime(int32_t timeOff);
bool IsSynced();
bool IsInUnsyncedList();
void SetInUnsyncedList(bool mode);

void UpdatePing(MillisInt time);
int16_t GetPing();

~ConnectionState();

--
uint8_t nodeID;

TimePoint lastSyncRequestSentTime;
int32_t syncRequestSendDelay;

comnet::constate::TimePoint lastCheckConnectRequestSentTime;
int32_t checkConRequestSendDelay;
uint8_t numUnansweredCheckConRequests;

comnet::constate::TimePoint lastCheckConnectReplySentTime;

uint8_t numSyncRepliesReceived;

bool inUnsyncedList;
int32_t timeOff;
uint8_t numSyncRepliesReceived;
int64_t unixHighResTimeDif;

int16_t ping;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1096</x>
      <y>2800</y>
      <w>24</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>968</x>
      <y>2088</y>
      <w>24</w>
      <h>88</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;90.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>856</x>
      <y>2016</y>
      <w>264</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>CheckConnectRequest
--
CheckConnectReply();
void Pack(comnet::serialization::ObjectStream&amp;);
void Unpack(comnet::serialization:ObjectStream&amp;);
comnet::AbstractPacket* Create();</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1200</x>
      <y>2088</y>
      <w>24</w>
      <h>88</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;90.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1128</x>
      <y>2016</y>
      <w>264</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>CheckConnectReply
--
CheckConnectReply();
void Pack(comnet::serialization::ObjectStream&amp;);
void Unpack(comnet::serialization:ObjectStream&amp;);
comnet::AbstractPacket* Create();</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1224</x>
      <y>1512</y>
      <w>48</w>
      <h>520</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;520.0;40.0;520.0;40.0;630.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>312</x>
      <y>2016</y>
      <w>264</w>
      <h>96</h>
    </coordinates>
    <panel_attributes>TimeSyncRequest
--
CheckConnectReply();
void Pack(comnet::serialization::ObjectStream&amp;);
void Unpack(comnet::serialization:ObjectStream&amp;);
comnet::AbstractPacket* Create();
--
int64_t unixHighResTimeDif;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>584</x>
      <y>2016</y>
      <w>264</w>
      <h>104</h>
    </coordinates>
    <panel_attributes>TimeSyncReply
--
CheckConnectReply();
void Pack(comnet::serialization::ObjectStream&amp;);
void Unpack(comnet::serialization:ObjectStream&amp;);
comnet::AbstractPacket* Create();
--
int32_t requestSentTime;
int64_t unixTimeHighResTimeDif;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>968</x>
      <y>1512</y>
      <w>280</w>
      <h>520</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>330.0;10.0;330.0;520.0;10.0;520.0;10.0;630.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>720</x>
      <y>1512</y>
      <w>528</w>
      <h>520</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>640.0;10.0;640.0;520.0;10.0;520.0;10.0;630.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>440</x>
      <y>1512</y>
      <w>808</w>
      <h>520</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>990.0;10.0;990.0;520.0;10.0;520.0;10.0;630.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>720</x>
      <y>2112</y>
      <w>24</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;60.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>432</x>
      <y>2104</y>
      <w>24</w>
      <h>72</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;70.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLPackage</id>
    <coordinates>
      <x>304</x>
      <y>1880</y>
      <w>1096</w>
      <h>1776</h>
    </coordinates>
    <panel_attributes>ConState
--
bg=orange
layer=-1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2952</x>
      <y>2776</y>
      <w>480</w>
      <h>632</h>
    </coordinates>
    <panel_attributes>TCPLink
--
static const int ACCEPT_DELAY_MILLIS;
static const int RECV_PORT_ATTEMPTS;
static const int RECV_PORT_DELAY_MILLIS;
static const int RECV_PORT_REPLY_ATTEMPTS;
static const int RECV_PORT_REPLY_DELAY_MILLIS;

static const int CON_DELAY_MILLIS;
static const uint8_t PORT_PAYLOAD_SIZE;
static const uint8_t PORT_REPLY_SIZE;

static const uint8_t ADD_QUEUE_EVENT;
static const uint8_t REMOVE_QUEUE_EVENT;

TCPLink();

bool InitConnection(const char* port, const char* address, uint32_t baudrate);
bool AddAddress(uint8_t dest_id, const char* address, uint16t port);
bool RemoveAddress(uint8_t dest_id);
bool Send(uint8_t dest_id, int8_t* tx_data, uint32_t tx_length);
bool Recv(uint8_t* rx_data, uint32_t* rx_length);
void DigestCommand(const char* cmd);
--
bool RunHandlers();
void AcceptHandler();
void ConnectHandler();
bool SetSocket(uint8_t id, CommSocket* replacement);
bool Connect(std::shared_ptr&lt;TCPHolder&gt; conInfo);
bool ShouldConnect(std::shared_ptr&lt;TCPHolder&gt; conInfo);
uint8_t AddressToID(USHORT port, IN_ADDR address, CommSocket* socket, bool&amp; success);

CommSocket* local;
IN_ADDR localIP;
USHORT localPort;

std::list&lt;std::shared_ptr&lt;TCPHolder&gt;&gt; connectLIst;
std::queue&lt;std::pair&lt;bool, std::shared_ptr&lt;TCPHolder&gt;&gt; connectModifyQueue;
comnet::architecture::os::CommMutex connectModifyQueueMutex;
comnet::architecture::os::CommThread* connectThread;
comnet::architecture::os::CommConditionVariable connectCondVar;

std::list&lt;std::shared_ptr&lt;TCPHolder&gt;&gt; acceptList;
std::queue&lt;std::pair&lt;bool, std::shared_ptr&lt;TCPHolder&gt;&gt; acceptModifyQueue;
comnet::architecture::os::CommMutex acceptModifyQueueMutex;
comnet::architecture::os::CommThread* acceptThread;
comnet::architecture::os::CommConditionVariable acceptCondVar;

std::unordered_map&lt;uint8_t, std::shared_ptr&lt;TCPHolder&gt;&gt; clients;
comnet::architecture::os::CommMutex clientsMutex;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2720</x>
      <y>3000</y>
      <w>248</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2984</x>
      <y>2576</y>
      <w>416</w>
      <h>176</h>
    </coordinates>
    <panel_attributes>TCPHolder
--
TCPHolder(TCPHolder&amp; copy, CommSocket* replacement);
TCPHolder(uint16_t port, const char* addr, uint8_t destID, CommSocket* socket);

~TCPHolder();

bool connect;
USHORT port;
IN_ADDR address;
CommSocket* socket;
uint16_t portInput;
std::string addressInput;
uint8_t destID;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3184</x>
      <y>2744</y>
      <w>24</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;40.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3536</x>
      <y>2936</y>
      <w>648</w>
      <h>248</h>
    </coordinates>
    <panel_attributes>TcpSocket
--
static void InitializeSockAddr(const char* address, PORT port, struct sockaddr_in* s);

TcpSocket();
~TcpSocket();

int32_t SockConnect(const char* address, PORT port) override;
int32_t SockSend(const char* buffer, uint32_t len, const char* address, uint32_t port) override;
packet_data_status_t SocckReceive(cosnt char* buffer, uint32_t len, uint32_t&amp; size, const char* address, uint32_t port) override;
//NOT IMPLEMENTED
int32_t SockAsyncConnect(const char* address, uint32_t port);
int32_t SockListen(const char* address, uint32_t port) override;
//NOT IMPLEMENTED
int32_t SockListen(uint32_t port) override;
CommSocket* SockAccept() override;
CommSocket* SockAccept(sockaddr_in&amp; connectedAddress) override;
void SockClose() override;
bool SetTcpNoDelay(SOCKET sock, bool on);
--
TcpSocket(SOCKET socket);
CommSocket* CreateTcpSocket();</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3544</x>
      <y>2768</y>
      <w>640</w>
      <h>136</h>
    </coordinates>
    <panel_attributes>/CommSocket/
--
~CommSocket();

virtual int32_t SockSend(const char* buffer, uint32_t len, const char* address, uint32_t port) = 0;
virtual packet_data_status_t SockReceive(const char* buffer, uint32_t len, uint32_t&amp; size, const char* address, uint32_t port) = 0;
virtual int32_t SockConnect(const char* address, uint32_t port) = 0;
virtual int32_t SockAsyncConnect(const char* address, uint32_t port) = 0;
virtual int32_t SockListen(const char* address, uint32_t port) = 0;
virtual int32_t SockListen(uint32_t port) = 0;
virtual CommSocket* SockAccept() = 0;
virtual CommSocket* SockAccept(sockaddr_in&amp; connectedAddress) = 0;
virtual void SockClose() = 0;

CommSocket* CreateTcpSocket();
CommSocket* CreateUdpSocket();//NOT IMPLEMENTED</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3856</x>
      <y>2896</y>
      <w>24</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3424</x>
      <y>3056</y>
      <w>128</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2296</x>
      <y>3256</y>
      <w>152</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>serial_info (serial_t)
--
speed_t baudrate;
serial_status serial_s;
port_id fd;
serial_h h_serial;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2360</x>
      <y>3328</y>
      <w>24</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;60.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2456</x>
      <y>3216</y>
      <w>472</w>
      <h>128</h>
    </coordinates>
    <panel_attributes>Parser
--
Parser();
~Parser();
void ParseSend(uint8_t* tx_data, uint32_t tx_length, uint8_t* crc_data, uint8_t* parsed_data);
bool ParseReceive(uint8_t* rx_data, uint32_t&amp; rx_length, uint8_t *parsed_data);
bool ParseReceiveDone();
--
char terminal_sequence;
uint32_t parser_position;
uint32_t last_received_length;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2560</x>
      <y>3336</y>
      <w>24</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;50.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3248</x>
      <y>472</y>
      <w>248</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>/ObjSerializable/
--
+virtual void Input(ObjectStream&amp; obj) const = 0;
+virtual void Output(ObjectStream&amp; obj) = 0;
layer=1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3200</x>
      <y>488</y>
      <w>64</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=&lt;.
&lt;&lt;uses&gt;&gt;</panel_attributes>
    <additional_attributes>60.0;20.0;10.0;20.0</additional_attributes>
  </element>
</diagram>
