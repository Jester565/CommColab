<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.2">
  <zoom_level>10</zoom_level>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>180</x>
      <y>0</y>
      <w>320</w>
      <h>460</h>
    </coordinates>
    <panel_attributes>//Abstract class to be used for determining what data should be sent and what callback to use when received.  Has a unique key to distinguish it from other packets.
AbstractPacket
--
public:
//New instance of AbstractPacket, sets the typeID attribute to the hash of typeIDHashKey
AbstractPacket(const char* typeIDHashKey);

//Accessor for the id of the packet, used to set the msg_id of a header
uint32_t GetID() const;

//Serializes the contents of the packet to the outStream parameter (pure virtual).  Called by Comm::send.
void Pack(ObjectStream&amp; outStream) = 0;

//Parses the contents of the packet from the inStream parameter (pure virtual)
void Unpack(ObjectStream&amp; inStream) = 0;

//Casts AbstractPacket to Type and returns it (return by reference evil?)
static Type&amp; GetValue(AbstractPacket&amp; packet);

//Returns a new instance of some child of AbstractPacket (pure virtual).  Used by PacketFactory.
AbstractPacket* Create() = 0;

//Default destructor
~AbstractPacket();

private:
//Default constructor (maybe this shouldn't exist?)
AbstractPacket();

//Accessed by getID(), set by constructor. Identification number for the packet.
uint32_t type_id;

--

//Call from child's constructor to AbstractPacket's constructor.  Pass in the type of the child and it
//will be converted into a const char* and be passed into AbstractPacket constructor as classname parameter.
CHAIN_ABSPACKET(class_name)

//Example - class Packet : INHERITS_ABSPACKET {};
INHERITS_ABSPACKET

//Defined as the name of the class representing the abstractpacket (so in this case comnet::AbstractPacket)
ABSPACKET</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>0</x>
      <y>1700</y>
      <w>310</w>
      <h>510</h>
    </coordinates>
    <panel_attributes>api.h
--

--
//Hexidecmial representatoin of the minimum version of the library
_COMNET_MINIMUM_API_VERSION_

//Hexidecimal representation of the last version of the library that has the same method names (no deprecated methods)
_COMNET_COMPATIBLE_API_VERSOIN_

//Hexidecimal representation of the current version of the library (Should be greater than COMENT_COMPATIBLE_API_VERSION_ and COMNET_MINIMUM_API_VERSION_
_COMNET_CURRENT_API_VERSION_

//I still don't really know what this does... you pass it one of the API_VERSOIN defines and it just gives you the hexideceimal (so it just returns the parameter you passed it...)
obtain_api_version(_api_version)

//Put before classes to denote what part of the API they are (public in this case).  Never get rid of this define or the program won't compile.
_COMNET_PUBLIC_API_

//Put before classes to denote what part of the API they are (general in this case).  Never get rid of this define or the program won't compile.
_COMNET_API_

//Put before classes to denote what part of the API they are (private in this case).  Never get rid of this define or the program won't compile.
_COMNET_API_PRIVATE_

//Not implemented anywhere yet.  Denotes how much implementers of the library will have to see the classes 0 means they will probably never see it and 5 means they will see it.  Just a guess though.
_COMNET_API_LEVEL_(UNKNOWN, 0, 1, 2,3,4,5)_

//Replace for class so that the class behaving as an interface is more clear.  Not implemented anywhere.
_COMNET_INTERFACE_

//Replace for class so that the class behaving as an abstract class is more clear.  Not implemented anywhere.
_COMNET_ABSTRACT_

//Replace for class so that the class behaving as a normal class is more clear.  Not implemented anywhere.
_CLASS_

//Retunrs the value of _COMNET_CURRENT_API_VERSION_
_current_api_version obtain_api_version(_COMNET_CURRENT_API_VERSION_)

//This define is put in classes that should be apart of the DLL.  However, when in static library mode, this is left blank.
COMM_EXPORT

//Not sure what the purpose of this is.  Usually the linker will figure out dll imports for you.
COMM_IMPORT

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>60</x>
      <y>1360</y>
      <w>190</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>arch.h
--

--
//Set to one of the defines below based on macro detection of which OS the library is being built on
COM_TARGET_OS

COM_OS_UNKNOWN

COM_OS_WINDOWS

COM_OS_LINUX

//Not used
COM_OS_QX

//Not used
COM_OS_BSD</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>140</x>
      <y>1600</y>
      <w>30</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>530</x>
      <y>2470</y>
      <w>400</w>
      <h>470</h>
    </coordinates>
    <panel_attributes>Comms
--
//Will create a certain subclass of CommsLink based on the parameter conn_type and will open a socket on this machine (Address is not used).
bool InitConnection(transport_protocol_t conn_type, const char* port, const char* address, uint32_t baudrate);</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>550</x>
      <y>1990</y>
      <w>340</w>
      <h>420</h>
    </coordinates>
    <panel_attributes>//Abstract class that will allow for easy adjustments in node changing and style.
/CommsNode/
--
//Initially 0, is incremented every time a CommNode is created so the value of unique_id can be set to this value.
static uint16_t number_of_nodes;

//Sets unique_id to number_of_nodes, increments number_of_nodes.  Sets attributes to default.
CommNode();

//Sets node_id to the parameter platform_id (this name is a bit confusing to me).
//Sets unique_id to number_of_nodes, increments number_of_nodes.  Sets attributes to default.
CommNode(const uint32_t platform_id);

//Delets the recv_queue and send_queue
//MEMEORY LEAK: Elements inside the queues are not deleted! (Not too sure about this yet)
~CommNode();

//Calls packet_manger.Insert to add packet to table.  Callback is set to NULL.  True if added successfull.
bool AddPacket(const AbstractPacket* packet);

//Calls packet_manager.Insert to add packet, callback pair to table.  True if added successfully.
bool LinkCallback(AbstractPacket* packet, const Callback* callback);

//Not implemented
bool LinkQueue(const AbstractPacket* packet, const Queue&lt;AbstractPacket*&gt;* queue);

//Delete the current send_queue and reassign it to the one passed as a parameter.
bool ReplaceSendQueue(const Queue&lt;ObjectStream*&gt;* queue);

//Delete the current recv_queue and reassign it to the one passed as a parameter.
bool ReplaceReceiveQueue(const Queue&lt;AbstractPacket*&gt;* queue);

//Send packet to specified destination.
bool Send(AbstractPacket* packet, uint8_t dest_id) = 0;

//Checks if data was received, if it was, the AbstractPacket is created, the corresponding callback is called, and the abstractpacket is returned.
AbstractPacket* Receive(uint8_t&amp; source_id) = 0;

//Will initialize a connection device
bool InitConnection(transport_protocol_t conn_type, const char* port, const char* address, uint16_t port) = 0;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>720</x>
      <y>2400</y>
      <w>30</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>550</x>
      <y>1470</y>
      <w>350</w>
      <h>480</h>
    </coordinates>
    <panel_attributes>PacketManager
--
//Initializes table to DEFAULT_TABLE_SIZE
PacketManager();

//Initializes table to the parameter value
PacketManager(uint32_t setSize);

//Deletes the table
~PacketManager();

//Inserts 2 parameters as a pair into list
bool Insert(const AbstractPacket* key, const Callback* callback);

//Calls table-&gt;GetCallback, gets the Callback associated with the key, null if key doesn't exist in the table.
Callback* PacketManager::Get(const AbstractPacket&amp; key);

//Calls table-&gt;remove true if removed successfully, false otherwise. 
//WILL FAIL EVERY TIME RIGHT NOW
bool Remove(const AbstractPacket* key);

//NOT IMPLEMENTED
bool Contains(const AbstractPacket&amp; key);

//NOT IMPLEMENTED
//Well, this would certainly be a slow lookup, is it necessary
bool Contains(Callback* call);

//Accessor for size attribute
int32_t GetSize();

//Uses factory to create a new instance of a AbstractPacket subtype of the AbstractPacket saved at the key.  Nullptr if key has no elements or AbstractPacket::Create returns nullptr.
AbstractPacket* ProduceFromId(uint32_t key);

private:
//Used in ProduceFromId method.  Creates instance of AbstractPacket matching subtype of other AbstractPacket.
PacketFactory factory;

//Hashtable storing AbstractPacket and Callback pairs
PacketTable* table;

//Stores amount of pairs in table
//THIS SHOULDN'T EXIST
int32_t size;

//THIS SHOULDN't EXIST
int32_t MaxSize;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>720</x>
      <y>1940</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>760</x>
      <y>1280</y>
      <w>310</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>//Creates new packets of the same sub-type of the AbstractPacket that was passed in.
PacketFactory
--
//Sets id to 1 (no idea what id is supposed to do)
PacketFactory();

//Takes a packet and returns AbstractPacket::create() if that packet was not nullptr.
AbstractPacket* ProduceNewPacket(AbstractPacket* ref);

private:
//No idea what this does.  Is not currently used anywher.
uint32_t id;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>730</x>
      <y>1410</y>
      <w>200</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>180.0;10.0;160.0;30.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>380</x>
      <y>1110</y>
      <w>320</w>
      <h>310</h>
    </coordinates>
    <panel_attributes>//Implementation of a hashtable for AbstractPackets and CallBacks
/PacketTable/
--
//Creates an array of null pointers to Pair arrays that will be the size of the parameter
PacketTable(uint32_t setSize);

//Creates an array of null pointers to Pair arrays that will be the size of DEFAULT_TABLE_SIZE
PacketTable();

//Deletes all the elements inside of the pairs that make up the table and then deletes the table/
~PacketTable();

//Inserts an element into the hashtable.  Will fail if array is full.  Returns true if element was added successfully.
//Called by PacketManager::insert
bool Insert(const AbstractPacket* key, const Callback* callback);

//Gets the element at the hashed key and returns the callback, nullptr if no element exists at the key.
Callback* GetCallback(uint32_t key);

//Gets the element at the hashed key and returns the AbstractPacket, nullptr if no element exists at the key.
AbstractPacket* PacketTable::GetPacket(uint32_t key);

//Pointer to a callback
bool Contains(Callback* call);

//Removes the pair with the matching key from the array.  True on success, false otherwise.
bool Remove(uint32_t key);

//Aquires more memory for the Pairs.  Cannot decrease the size of the memory.
bool Reserve(uint32_t newSize);</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>550</x>
      <y>1410</y>
      <w>190</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>920</x>
      <y>2280</y>
      <w>660</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>640.0;60.0;600.0;10.0;110.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1520</x>
      <y>2340</y>
      <w>390</w>
      <h>360</h>
    </coordinates>
    <panel_attributes>/CommsLink/
--
//Default constructor.
CommsLink();

//Default destructor.
~CommsLink();

//Opens a socket on the machine (address is not used).
bool InitConnection(const char* port = NULL, const char* address, uint32_t baudrate);

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1120</x>
      <y>2920</y>
      <w>330</w>
      <h>340</h>
    </coordinates>
    <panel_attributes>UDPLink
--
//Sets protocol to UDP_LINK
UDPLink();

//Closes local
~UDPLink();
//Initializes local object and binds it to the port parameter on localhost.
bool InitConnection(const char* port = NUll, const char* address = NULL, uint16_t port) = 0;

//Initializes a udp object and adds it to clients. Returns true on successful connection.
bool AddAddress(uint8_t dest_id, const char* address, uint16_t port);

//Removes the client with the dest_id.  True on successful removal.
bool RemoveAddress(uint8_t dest_id);

//Sends data to the client with the dest_id.
bool Send(uint8_t dest_id, int8_t* txData, uint32_t txLength);

//Receives data from all clients.
bool Recv(int8_t* rxData, uint32_t* rxLength);

//Not implemented
void DigestCommand(const char* cmd);

private:
//Doesn't send or receive anything. Initializes and opens the socket.
UDP local;

//Contains all of the clients connected to this socket.
std::map&lt;uint8_t, std::unique_ptr&lt;UDP&gt;&gt; clients;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1440</x>
      <y>2690</y>
      <w>120</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;.</panel_attributes>
    <additional_attributes>100.0;10.0;60.0;200.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1540</x>
      <y>3290</y>
      <w>350</w>
      <h>440</h>
    </coordinates>
    <panel_attributes>SerialLink
--</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2010</x>
      <y>2910</y>
      <w>360</w>
      <h>440</h>
    </coordinates>
    <panel_attributes>XBeeLink
--</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1460</x>
      <y>2690</y>
      <w>120</w>
      <h>620</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;.</panel_attributes>
    <additional_attributes>100.0;10.0;50.0;220.0;10.0;290.0;10.0;540.0;90.0;600.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1900</x>
      <y>2640</y>
      <w>310</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;270.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1700</x>
      <y>2200</y>
      <w>30</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1610</x>
      <y>2130</y>
      <w>210</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>transport_protocol_t
--</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1270</x>
      <y>2890</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1120</x>
      <y>2490</y>
      <w>330</w>
      <h>410</h>
    </coordinates>
    <panel_attributes>UDP
--
//Default constructor.
UDP();

//Move constructor.  Uses copy and swap idiom.
UDP(UDP&amp;&amp; udp);

//Default destructor.
~UDP();

//Calls UdpOpen and binds the socket to the port passed in as a parameter.
bool InitConnection(const char* port = NULL, const char* address = NULL, uint32_t baudrate = 0);

//If the socket is open, create and return a UDP object representing a client with the IP of the parameters passed in.
std::unique_ptr&lt;UDP&gt; Connect(uint8_t dest_id, const char* address = NULL, uint16_t port = 0);

//Sends the data array by using the sendto function in the OS API.
bool Send(uint8_t* tx_data, uint32_t tx_length);

//If data was received, set the rx_data array to the data that was received and return true.
bool Recv(uint8_t* rx_data, uint32_t* rx_length);

//Closes the socket if the socket is not already closed. True on success.
bool Close();

private:
//Initializes UDP socket
UdpOpen(int* fd);

//The socket id, set by UdpOpen.
int fd;

//The IP address of the UDP socket.
socket_t sockaddr;

//The size of sockaddr.socket_address in bytes.
int slen;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1180</x>
      <y>2310</y>
      <w>200</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>socket_t
--
//Integer that holds the socket identication number for calls to winsock.
SOCKET socket;

//Port the socket binds to.
PORT port;

//Holds the destination id of the UDP object.
ID_T id;

//Either SOCKET_OPEN, SOCKET_CLOSED, SOCKET_RESOLVING, SOCKET_CONNECTING, SOCKET_CONNECTED, SOCKET_LISTENING, SOCKET_FAILED
socket_status_t socket_status;

//Holds the information necessary for calls to send and receive.
struct sockaddr_in socket_address;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1270</x>
      <y>2460</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1130</x>
      <y>1860</y>
      <w>360</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>AESEncryption
--</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>890</x>
      <y>2040</y>
      <w>260</w>
      <h>450</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>240.0;10.0;180.0;50.0;10.0;430.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>590</x>
      <y>160</y>
      <w>320</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>//Stores an std::function (typedefed as CallbackFunc) that is invoked by CallFunction
//WARNING: CallbackFunc is a typedef of std::function but takes the appropiate parameters and has the right return type
Callback
--
public:
//Initializes the CallbackFunc to a method that returns -100
Callback();

//Initialize the Callback and set the CallbackFunc to the parameter.  Function must take parameters: const Header&amp; header, AbstractPacket&amp; abPacket, CommNode&amp; node
Callback(CallbackFunc call);

//Default destructor
~Callback();

//Set the CallbackFunc to the parameter, the function must take parameters: const Header&amp; header, AbstractPacket&amp; abPacket, CommNode&amp; node
void SetCallbackListener(CallbackFunc call);

//Called by Comms::CommunicationHandlerRecv and will run the method and will pass in the appropiate parameters
error_t CallFunction(const Header&amp; header, AbstractPacket&amp; abPacket, CommNode&amp; node);

private:
//Remember that CallBackFunc is a typedef for std::function.  Must take the parameters (const Header&amp;, AbstractPacket&amp;, CommNode&amp;)
CallBackFunc callback;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>530</x>
      <y>1050</y>
      <w>30</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>390</x>
      <y>600</y>
      <w>310</w>
      <h>460</h>
    </coordinates>
    <panel_attributes>PacketHashTable
--
//Creates an array of null pointers to Pair arrays that will be the size of the parameter
PacketTable(uint32_t setSize);

//Creates an array of null pointers to Pair arrays that will be the size of DEFAULT_TABLE_SIZE
PacketTable();

//Deletes all the elements inside of the pairs that make up the table and then deletes the table/
~PacketTable();

//Inserts an element into the hashtable.  Will fail if array is full.  Returns true if element was added successfully.
//Called by PacketManager::insert
bool Insert(const AbstractPacket* key, const Callback* callback);

//Gets the element at the hashed key and returns the callback, nullptr if no element exists at the key.
Callback* GetCallback(uint32_t key);

//Gets the element at the hashed key and returns the AbstractPacket, nullptr if no element exists at the key.
AbstractPacket* PacketTable::GetPacket(uint32_t key);

//Not implemented yet
bool Remove(uint32_t key);

//Not implemented yet
bool Resize(uint32_t newSize);

private:
//Increments i, sets it to 0 if greater than or equal to tableSize.  Called by Insert.
int32_t TraverseIndex(int32_t i);

//Hashes the key and returns an integer between 0 and tableSize (but no equal to tableSize)
uint32_t KeyHash(uint32_t key);

//An array of Pair* with size tableSize.  Where all the elements are inserted, etc.
Pair** table;

//Number of elements in the array.
uint32_t numOfPairs;

//The maximum amount of elements that can be stored in the map before a resize is needed.
uint32_t tableSize;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>310</x>
      <y>450</y>
      <w>250</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0;230.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>530</x>
      <y>440</y>
      <w>250</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>230.0;10.0;200.0;50.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1540</x>
      <y>2870</y>
      <w>350</w>
      <h>390</h>
    </coordinates>
    <panel_attributes>Serial
--
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1700</x>
      <y>3250</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
</diagram>
